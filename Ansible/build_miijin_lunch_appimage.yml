---
- name: Build MiijinLunch AppImage on AlmaLinux
  hosts: all
  become: true
  gather_facts: true

  vars:
    repo_url: "https://github.com/BayMillsCC/Miijin"
    repo_dest: "/opt/Miijin"

    # version used in the output AppImage filename
    appimage_version: "1.1"

    # Map ansible_architecture -> AppImage arch token
    appimage_arch_map:
      x86_64: "x86_64"
      amd64: "x86_64"
      aarch64: "aarch64"
      arm64: "aarch64"

    appimage_arch: "{{ appimage_arch_map.get(ansible_architecture, ansible_architecture) }}"
    appimage_filename: "MiijinLunch-{{ appimage_version }}-{{ appimage_arch }}.AppImage"

    # Where we install it system-wide
    appimage_install_path: "/usr/local/bin/{{ appimage_filename }}"

    # Local file on the CONTROL machine
    # This gets copied to the remote repo path.
    postgres_config_src: "files/postgres_config.py"
    postgres_config_dest: "{{ repo_dest }}/src/Miijin/MiijinDatabase/postgres_config.py"

    venv_path: "{{ repo_dest }}/.venv"
    venv_python: "{{ venv_path }}/bin/python"
    venv_pip: "{{ venv_path }}/bin/pip"

  tasks:
    - name: Install system dependencies (Alma/RHEL)
      ansible.builtin.dnf:
        name:
          - git
          - fuse
          - python3
          - python3-pip
          - gcc
          - make
          - python3-devel
          - libffi-devel
          - openssl-devel
        state: present

    - name: Enable EPEL (ARM only)
      ansible.builtin.dnf:
        name: epel-release
        state: present
      when: ansible_architecture in ['aarch64', 'arm64']

    - name: Install patchelf (ARM only)
      ansible.builtin.dnf:
        name: patchelf
        state: present
      when: ansible_architecture in ['aarch64', 'arm64']

    - name: Remove existing Miijin workspace (controlled rebuild)
      ansible.builtin.file:
        path: "{{ repo_dest }}"
        state: absent

    - name: Clone/update Miijin repo
      ansible.builtin.git:
        repo: "{{ repo_url }}"
        dest: "{{ repo_dest }}"
        version: "HEAD"
        force: false
        update: true

    - name: Create virtual environment if missing
      ansible.builtin.command: "python3 -m venv {{ venv_path }}"
      args:
        creates: "{{ venv_python }}"

    - name: Upgrade pip in venv
      ansible.builtin.pip:
        name: pip
        state: latest
        virtualenv: "{{ venv_path }}"
        virtualenv_command: "python3 -m venv"

    - name: Install Python requirements into venv
      ansible.builtin.pip:
        requirements: "{{ repo_dest }}/requirements.txt"
        virtualenv: "{{ venv_path }}"
        virtualenv_command: "python3 -m venv"

    - name: Copy postgres_config.py into repo (from control node)
      ansible.builtin.copy:
        src: "{{ postgres_config_src }}"
        dest: "{{ postgres_config_dest }}"
        owner: root
        group: root
        mode: "0644"

    - name: Build AppImage (bdist_appimage)
      ansible.builtin.command: "{{ venv_python }} setup_lunch.py bdist_appimage"
      args:
        chdir: "{{ repo_dest }}"

    - name: Verify built AppImage exists in dist/
      ansible.builtin.stat:
        path: "{{ repo_dest }}/dist/{{ appimage_filename }}"
      register: built_appimage

    - name: Fail if AppImage was not produced
      ansible.builtin.fail:
        msg: "Expected AppImage not found: {{ repo_dest }}/dist/{{ appimage_filename }}"
      when: not built_appimage.stat.exists

    - name: Install AppImage system-wide to /usr/local/bin
      ansible.builtin.copy:
        src: "{{ repo_dest }}/dist/{{ appimage_filename }}"
        dest: "{{ appimage_install_path }}"
        remote_src: true
        owner: root
        group: root
        mode: "0755"

    - name: Show installed AppImage path
      ansible.builtin.debug:
        msg: "Installed: {{ appimage_install_path }} (arch={{ ansible_architecture }})"